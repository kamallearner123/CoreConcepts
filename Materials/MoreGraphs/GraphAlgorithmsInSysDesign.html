<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms in System Design - Detailed Exploration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        .highlight {
            background-color: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .section {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        pre {
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            border-left: 4px solid #3498db;
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        .example {
            background-color: #fefefe;
            border: 1px dashed #3498db;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .sub-section {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Graph Algorithms in System Design: A Detailed Exploration</h1>

    <!-- Intro -->
    <div class="section">
        <h2>1. What Are Graph Algorithms?</h2>
        <p>Graph algorithms are like the <span class="highlight">superpowers</span> of system design—they take a graph (nodes and edges) and solve real-world problems fast! In system design, they’re key for tasks like finding routes, exploring connections, ranking importance, or ordering dependencies. Let’s dive into the big ones!</p>
    </div>

    <!-- Shortest Path Algorithms -->
    <div class="section">
        <h2>2. Shortest Path Algorithms</h2>
        <p>These algorithms find the <span class="highlight">quickest way</span> from one node to another in a weighted graph—think GPS or network routing. Here’s the trio:</p>

        <h3>2.1 Dijkstra’s Algorithm</h3>
        <div class="sub-section">
            <p><span class="highlight">Dijkstra’s</span> finds the shortest path from a single starting node to all others, assuming <span class="highlight">non-negative weights</span>. It’s greedy—always picking the cheapest next step. Time complexity: \( O((V + E) \log V) \) with a priority queue.</p>
            <p><strong>Simple Graph:</strong></p>
            <pre>
            A --2--> B --3--> C
            |        |
            5       1
            |        |
            D --4--> E
            (Shortest path A to E: A -> B -> E, cost = 3)
            </pre>
            <div class="example">
                <h4>Example: GPS Navigation</h4>
                <p>In Google Maps, roads are edges with weights (time). Dijkstra’s finds the fastest route from home to work.</p>
                <p><strong>Why It’s Cool:</strong> Saves you from traffic jams!</p>
            </div>
        </div>

        <h3>2.2 A* Algorithm</h3>
        <div class="sub-section">
            <p><span class="highlight">A*</span> is Dijkstra’s smarter cousin—it uses a <span class="highlight">heuristic</span> (like straight-line distance) to guess the best path, making it faster. Time depends on the heuristic but is often better than Dijkstra’s.</p>
            <p><strong>Simple Graph:</strong></p>
            <pre>
            A --2--> B --3--> Goal
            |        |
            5       1
            |        |
            C --4--> D
            (A* picks A -> B -> Goal, guided by heuristic)
            </pre>
            <div class="example">
                <h4>Example: Video Game Pathfinding</h4>
                <p>In games like Zelda, A* helps characters navigate obstacles to reach you—fast and smooth!</p>
                <p><strong>Why It’s Cool:</strong> Makes games feel alive.</p>
            </div>
        </div>

        <h3>2.3 Bellman-Ford Algorithm</h3>
        <div class="sub-section">
            <p><span class="highlight">Bellman-Ford</span> handles <span class="highlight">negative weights</span> and detects negative cycles (where costs loop lower forever). It’s slower—\( O(VE) \)—but more flexible.</p>
            <p><strong>Simple Graph:</strong></p>
            <pre>
            A --2--> B --3--> C
            |        |
            -1      4
            |        |
            D <---1-- E
            (Shortest path A to D: A -> D, cost = -1)
            </pre>
            <div class="example">
                <h4>Example: Currency Arbitrage</h4>
                <p>In finance, edges are exchange rates (some negative). Bellman-Ford spots profit loops!</p>
                <p><strong>Why It’s Cool:</strong> Catches money-making tricks.</p>
            </div>
        </div>
    </div>

    <!-- Graph Traversal Algorithms -->
    <div class="section">
        <h2>3. Graph Traversal Algorithms</h2>
        <p>These explore a graph’s nodes and edges—great for <span class="highlight">searching</span> or <span class="highlight">discovering</span> connections.</p>

        <h3>3.1 BFS (Breadth-First Search)</h3>
        <div class="sub-section">
            <p><span class="highlight">BFS</span> explores level by level—perfect for finding the <span class="highlight">shortest path</span> in unweighted graphs. Time: \( O(V + E) \).</p>
            <p><strong>Simple Graph:</strong></p>
            <pre>
            A --- B --- C
            |     |
            D --- E
            (BFS from A: A, B, D, C, E)
            </pre>
            <div class="example">
                <h4>Example: Social Media Connections</h4>
                <p>On LinkedIn, BFS finds your closest contacts (1st, 2nd-degree connections).</p>
                <p><strong>Why It’s Cool:</strong> Shows who’s near in your network!</p>
            </div>
        </div>

        <h3>3.2 DFS (Depth-First Search)</h3>
        <div class="sub-section">
            <p><span class="highlight">DFS</span> dives deep down one path before backtracking—great for <span class="highlight">cycles</span> or <span class="highlight">exhaustive search</span>. Time: \( O(V + E) \).</p>
            <p><strong>Simple Graph:</strong></p>
            <pre>
            A --- B --- C
            |     |
            D --- E
            (DFS from A: A, B, C, E, D)
            </pre>
            <div class="example">
                <h4>Example: Maze Solving</h4>
                <p>In a maze game, DFS explores every path to find the exit.</p>
                <p><strong>Why It’s Cool:</strong> Feels like an adventure!</p>
            </div>
        </div>
    </div>

    <!-- PageRank Algorithm -->
    <div class="section">
        <h2>4. PageRank Algorithm</h2>
        <p><span class="highlight">PageRank</span> ranks nodes by <span class="highlight">importance</span>—think Google ranking web pages. It assumes a node is important if many others link to it, especially important ones. Time per iteration: \( O(V + E) \).</p>
        <p><strong>Simple Graph:</strong></p>
        <pre>
        A --> B --> C
        |     ^
        D ----|
        (C gets high rank—B and D point to it!)
        </pre>
        <div class="example">
            <h4>Example: Search Engine Results</h4>
            <p>Google uses PageRank to prioritize popular pages—like Wikipedia over a random blog.</p>
            <p><strong>Why It’s Cool:</strong> Finds the best info fast!</p>
        </div>
        <div class="example">
            <h4>Example: Social Influence</h4>
            <p>X could rank influencers—someone with many followers who follow other big names gets a high score.</p>
            <p><strong>Why It’s Cool:</strong> Spots the real trendsetters.</p>
        </div>
    </div>

    <!-- Topological Sorting (DAGs) -->
    <div class="section">
        <h2>5. Topological Sorting (DAGs)</h2>
        <p><span class="highlight">Topological Sorting</span> orders nodes in a <span class="highlight">Directed Acyclic Graph (DAG)</span>—no cycles allowed—so every edge points forward. Time: \( O(V + E) \).</p>
        <p><strong>Simple Graph:</strong></p>
        <pre>
        A --> B --> C
        |     |
        D --> E
        (Order: A, D, B, E, C)
        </pre>
        <div class="example">
            <h4>Example: Task Scheduling</h4>
            <p>In a project, "Design" must finish before "Build," and "Build" before "Test." Topological sort orders it perfectly.</p>
            <p><strong>Why It’s Cool:</strong> Keeps work flowing smoothly!</p>
        </div>
        <div class="example">
            <h4>Example: Software Dependencies</h4>
            <p>Installing software—library A needs B, B needs C. Graphs sort the install order.</p>
            <p><strong>Why It’s Cool:</strong> No crashes from missing pieces!</p>
        </div>
    </div>

    <!-- Recap -->
    <div class="section">
        <h2>6. Recap: Graph Algorithms Power Systems</h2>
        <p>Graph algorithms are the <span class="highlight">engines</span> of system design. They find paths (Shortest Path), explore networks (Traversal), rank value (PageRank), and order tasks (Topological Sort). From maps to games to search to schedules, they’re the <span class="highlight">secret sauce</span> making systems smart and fast!</p>
    </div>

</body>
</html>